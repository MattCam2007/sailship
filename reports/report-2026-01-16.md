# 3D View Manipulation Implementation Plan

**Generated:** 2026-01-16
**Updated:** 2026-01-16 (with fixes from implementation review)
**Feature:** Right-Click Drag to Rotate View (Option A)

---

## Executive Summary

This plan details the implementation of intuitive 3D view manipulation for the solar system display. The current codebase already contains full 3D projection math but lacks UI controls to utilize it. This implementation adds right-click drag rotation while preserving existing left-click panning behavior.

**Key Deliverables:**
- Right-click drag for orbital rotation (angleZ) and tilt adjustment (angleX)
- Rotation-aware panning that works correctly at any view angle
- Keyboard shortcuts for rotation and view reset
- Optional UI reset button

**Review Status:** This plan has been reviewed for physics/realism, code functionality, architecture, and edge cases. All identified issues have been addressed.

---

## Current Architecture Analysis

### Existing Camera State (`src/js/core/camera.js:6-12`)

```javascript
export const camera = {
    angleX: 15 * Math.PI / 180,  // Tilt from horizontal (currently fixed)
    angleZ: 0,                    // Orbital rotation (currently unused)
    zoom: 1,
    target: { x: 0, y: 0, z: 0 },
    followTarget: null
};
```

### Existing Projection (`src/js/core/camera.js:75-99`)

The `project3D()` function already supports full 3D rotation:

1. Translates world coordinates by camera target
2. Rotates around Z-axis (orbital view rotation)
3. Rotates around X-axis (tilt/pitch)
4. Projects to 2D screen coordinates

**This projection is already complete and requires no modification.**

### Current Mouse Controls (`src/js/ui/controls.js:210-257`)

| Input | Current Behavior | Status |
|-------|------------------|--------|
| Left-click drag | Pan camera X/Y | Working |
| Scroll wheel | Zoom in/out | Working |
| Right-click | Browser context menu | Not utilized |

---

## Implementation Phases

### Phase 1: Core Rotation Controls

**File:** `src/js/ui/controls.js`

#### 1.1 Add Constants and State Objects

**Location:** After line 26 (after `dragState` definition)

```javascript
// Mouse button constants for readability
const MOUSE_BUTTON = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

// Rotation state for camera view manipulation
const rotateState = {
    isRotating: false,
    lastX: 0,
    lastY: 0
};
```

#### 1.2 Refactor `initMouseControls()` Function

**Location:** Replace lines 210-257

The complete refactored function with mutual exclusion and improved edge case handling:

```javascript
/**
 * Set up mouse controls (wheel zoom, drag to pan, right-drag to rotate)
 * @param {HTMLCanvasElement} canvas
 */
function initMouseControls(canvas) {
    // Prevent context menu on canvas to allow right-click rotation
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Wheel zoom (unchanged)
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        camera.zoom *= e.deltaY > 0 ? 0.9 : 1.1;
        camera.zoom = Math.max(0.1, Math.min(5, camera.zoom));
    });

    // Mousedown - determine action based on button (with mutual exclusion)
    canvas.addEventListener('mousedown', e => {
        if (e.button === MOUSE_BUTTON.LEFT && !rotateState.isRotating) {
            // Left-click: start panning (only if not already rotating)
            dragState.isDragging = true;
            dragState.lastX = e.clientX;
            dragState.lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
            stopFollowing();
        } else if (e.button === MOUSE_BUTTON.RIGHT && !dragState.isDragging) {
            // Right-click: start rotating (only if not already panning)
            rotateState.isRotating = true;
            rotateState.lastX = e.clientX;
            rotateState.lastY = e.clientY;
            canvas.style.cursor = 'move';
        }
    });

    // Mousemove - handle both pan and rotate
    canvas.addEventListener('mousemove', e => {
        if (dragState.isDragging) {
            handlePan(e);
        }
        if (rotateState.isRotating) {
            handleRotation(e);
        }
    });

    // Mouseup - end actions based on button released
    canvas.addEventListener('mouseup', e => {
        if (e.button === MOUSE_BUTTON.LEFT) {
            dragState.isDragging = false;
        } else if (e.button === MOUSE_BUTTON.RIGHT) {
            rotateState.isRotating = false;
        }
        if (!dragState.isDragging && !rotateState.isRotating) {
            canvas.style.cursor = 'default';
        }
    });

    // Mouseleave - only reset cursor, preserve state for potential re-entry
    canvas.addEventListener('mouseleave', () => {
        canvas.style.cursor = 'default';
    });

    // Mouseenter - check if buttons still held, reset state if released off-canvas
    canvas.addEventListener('mouseenter', e => {
        // e.buttons is a bitmask: 1 = left, 2 = right, 4 = middle
        if (dragState.isDragging && !(e.buttons & 1)) {
            dragState.isDragging = false;
        }
        if (rotateState.isRotating && !(e.buttons & 2)) {
            rotateState.isRotating = false;
        }
    });
}
```

#### 1.3 Add Rotation Handler Function

**Location:** Before `initMouseControls()` function

```javascript
/**
 * Handle camera rotation from mouse drag
 * @param {MouseEvent} e
 */
function handleRotation(e) {
    const deltaX = e.clientX - rotateState.lastX;
    const deltaY = e.clientY - rotateState.lastY;

    // Rotation sensitivity (radians per pixel)
    const sensitivity = 0.005;

    // Horizontal drag: orbital rotation around Z-axis
    camera.angleZ += deltaX * sensitivity;

    // Normalize angleZ to [0, 2*PI) range
    camera.angleZ = camera.angleZ % (2 * Math.PI);
    if (camera.angleZ < 0) camera.angleZ += 2 * Math.PI;

    // Vertical drag: tilt adjustment (pitch around X-axis)
    camera.angleX -= deltaY * sensitivity;

    // Clamp tilt between 0° (top-down) and 90° (edge-on)
    const minTilt = 0;
    const maxTilt = Math.PI / 2;
    camera.angleX = Math.max(minTilt, Math.min(maxTilt, camera.angleX));

    rotateState.lastX = e.clientX;
    rotateState.lastY = e.clientY;
}
```

**Rotation Behavior:**
- Drag right → Rotate view clockwise (looking from above)
- Drag left → Rotate view counter-clockwise
- Drag up → Increase tilt (more edge-on view)
- Drag down → Decrease tilt (more top-down view)

---

### Phase 2: Rotation-Aware Panning

**Problem:** Current panning assumes a fixed view orientation. When the view is rotated, dragging "right" on screen should still move the view "right" from the user's perspective, not in world X direction.

**File:** `src/js/ui/controls.js`

#### 2.1 Add Pan Handler Function

**Location:** Before `handleRotation()` function

```javascript
/**
 * Handle camera panning with rotation compensation
 * Uses INVERSE rotation matrix to convert screen-space deltas to world-space
 * @param {MouseEvent} e
 */
function handlePan(e) {
    const deltaX = e.clientX - dragState.lastX;
    const deltaY = e.clientY - dragState.lastY;

    const scale = getScale();
    const effectiveScale = scale * camera.zoom;

    // Convert screen delta to view-space delta
    const viewDeltaX = -deltaX / effectiveScale;
    const viewDeltaY = deltaY / effectiveScale;

    // Apply INVERSE rotation to convert screen-space to world-space
    // When view is rotated by angleZ, we need the transpose (inverse) of the rotation matrix
    const cosZ = Math.cos(camera.angleZ);
    const sinZ = Math.sin(camera.angleZ);

    // Inverse rotation matrix (transpose of forward rotation):
    // [cos(θ)   sin(θ)]   instead of   [cos(θ)  -sin(θ)]
    // [-sin(θ)  cos(θ)]                 [sin(θ)   cos(θ)]
    const worldDeltaX = viewDeltaX * cosZ + viewDeltaY * sinZ;
    const worldDeltaY = -viewDeltaX * sinZ + viewDeltaY * cosZ;

    camera.target.x += worldDeltaX;
    camera.target.y += worldDeltaY;

    dragState.lastX = e.clientX;
    dragState.lastY = e.clientY;
}
```

**Mathematical Explanation:**

The projection applies a forward rotation by `angleZ`. To convert screen coordinates back to world coordinates, we need the **inverse rotation** (which equals the transpose for rotation matrices).

Forward rotation matrix:
```
[cos(θ)  -sin(θ)]
[sin(θ)   cos(θ)]
```

Inverse rotation matrix (transpose):
```
[cos(θ)   sin(θ)]
[-sin(θ)  cos(θ)]
```

**Test case to verify correctness:**
- Rotate view 90° (angleZ = π/2)
- Drag right on screen (positive deltaX)
- Expected: View pans right from user's perspective
- With forward matrix: WRONG - pans in unexpected direction
- With inverse matrix: CORRECT - pans as expected

---

### Phase 3: Keyboard Shortcuts

**File:** `src/js/ui/controls.js`

#### 3.1 Add Camera Rotation Shortcuts

**Location:** Modify `initKeyboardShortcuts()` function (lines 168-203)

Add at the beginning of the keydown handler. Uses `break` instead of `return` to allow other handlers to run:

```javascript
document.addEventListener('keydown', e => {
    // Camera rotation shortcuts (always active, even during autopilot)
    const rotationStep = 0.05;  // ~3 degrees per press
    const tiltStep = 0.05;

    switch (e.key.toLowerCase()) {
        case 'q':
            // Rotate view counter-clockwise
            camera.angleZ -= rotationStep;
            if (camera.angleZ < 0) camera.angleZ += 2 * Math.PI;
            break;
        case 'e':
            // Rotate view clockwise
            camera.angleZ += rotationStep;
            camera.angleZ = camera.angleZ % (2 * Math.PI);
            break;
        case 'r':
            // Reset view to default (avoid conflict with browser refresh)
            if (!e.ctrlKey && !e.metaKey) {
                camera.angleX = 15 * Math.PI / 180;
                camera.angleZ = 0;
            }
            break;
        case 'w':
            // Tilt view more top-down
            camera.angleX = Math.max(0, camera.angleX - tiltStep);
            break;
        case 's':
            // Tilt view more edge-on
            camera.angleX = Math.min(Math.PI / 2, camera.angleX + tiltStep);
            break;
    }

    // Existing autopilot and sail controls follow...
    // (autopilot toggle with 'a', sail controls with '[', ']', '-', '=')
```

**Keyboard Shortcut Summary:**

| Key | Action |
|-----|--------|
| `Q` | Rotate view counter-clockwise |
| `E` | Rotate view clockwise |
| `W` | Tilt toward top-down view |
| `S` | Tilt toward edge-on view |
| `R` | Reset view to default (15° tilt, no rotation) |

**Note:** These shortcuts use `break` instead of `return` to ensure existing autopilot and sail control handlers still execute.

---

### Phase 4: Camera Reset Function (Optional)

**File:** `src/js/core/camera.js`

#### 4.1 Add Reset Function

**Location:** After `stopFollowing()` function

```javascript
/**
 * Reset camera view to default orientation
 */
export function resetCamera() {
    camera.angleX = 15 * Math.PI / 180;
    camera.angleZ = 0;
    camera.zoom = 1;
}
```

#### 4.2 Export the Function

Ensure `resetCamera` is exported and can be called from UI buttons.

---

### Phase 5: UI Reset Button (Optional)

**File:** `src/index.html`

#### 5.1 Add Reset Button to View Controls

**Location:** In the view/display options section

```html
<button id="resetViewBtn" class="control-btn" title="Reset view (R)">
    Reset View
</button>
```

**File:** `src/js/ui/controls.js`

#### 5.2 Add Button Handler

**Location:** In `initControls()` function or new init function

```javascript
function initViewControls() {
    const resetBtn = document.getElementById('resetViewBtn');
    if (resetBtn) {
        resetBtn.addEventListener('click', () => {
            camera.angleX = 15 * Math.PI / 180;
            camera.angleZ = 0;
        });
    }
}
```

---

## Complete Code Changes Summary

### File: `src/js/ui/controls.js`

| Section | Lines | Change Type | Description |
|---------|-------|-------------|-------------|
| Constants | After L26 | Add | `MOUSE_BUTTON` constants |
| State | After L26 | Add | `rotateState` object |
| New function | Before L210 | Add | `handlePan()` function (with inverse rotation) |
| New function | Before L210 | Add | `handleRotation()` function |
| `initMouseControls()` | L210-257 | Replace | Complete refactor with mutual exclusion |
| `initKeyboardShortcuts()` | L168-203 | Modify | Add Q/E/W/S/R camera shortcuts (using break) |
| `initControls()` | L32-41 | Modify | Add `initViewControls()` call (optional) |

### File: `src/js/core/camera.js`

| Section | Lines | Change Type | Description |
|---------|-------|-------------|-------------|
| New function | After L70 | Add | `resetCamera()` function (optional) |
| Exports | L1-5 | Modify | Export `resetCamera` (optional) |

### File: `src/index.html`

| Section | Change Type | Description |
|---------|-------------|-------------|
| View controls | Add | Reset view button (optional) |

---

## Testing Plan

### Manual Test Cases

#### TC1: Basic Rotation
1. Right-click and drag horizontally on canvas
2. **Expected:** View rotates around Sun (orbital rotation)
3. **Verify:** Objects maintain correct relative positions

#### TC2: Tilt Adjustment
1. Right-click and drag vertically on canvas
2. **Expected:** View tilts between top-down and edge-on
3. **Verify:** Tilt clamps at 0° and 90°

#### TC3: Rotation-Aware Panning
1. Rotate view 90° using right-click drag
2. Left-click drag horizontally
3. **Expected:** View pans in screen-relative direction, not world-X
4. **Verify:** Dragging right moves objects left on screen regardless of rotation

#### TC4: Combined Operations
1. Rotate view 45°
2. Pan to center on Mars
3. Zoom in
4. Rotate view another 30°
5. **Expected:** All operations work independently and correctly

#### TC5: Keyboard Shortcuts
1. Press Q multiple times → view rotates counter-clockwise
2. Press E multiple times → view rotates clockwise
3. Press W → view tilts toward top-down
4. Press S → view tilts toward edge-on
5. Press R → view resets to default

#### TC6: Edge Cases
1. Drag mouse outside canvas while rotating → rotation pauses
2. Return mouse to canvas with button still held → rotation resumes
3. Right-click without dragging → context menu suppressed
4. Rapid alternation between left and right drag → no state corruption

#### TC7: Rotation Matrix Verification
1. Rotate view exactly 90° (angleZ = π/2)
2. Drag right 100 pixels
3. **Expected:** View pans correctly in rotated frame (objects move left)
4. **Verify:** Does NOT pan up/down (would indicate matrix sign error)

#### TC8: Simultaneous Button Press
1. Press left mouse button, hold
2. While holding left, press right mouse button
3. **Expected:** Only panning occurs (first action wins due to mutual exclusion)
4. **Verify:** No rotation occurs, no state corruption

#### TC9: Off-Canvas Drag Resume
1. Start right-drag rotation
2. Move mouse outside canvas (keep button held)
3. Move mouse back onto canvas
4. **Expected:** Rotation resumes if button still held
5. **Verify:** State correctly detects held button via `e.buttons`

#### TC10: Keyboard During Autopilot
1. Enable autopilot (press A)
2. Press Q/E/W/S/R camera shortcuts
3. **Expected:** Camera shortcuts work even during autopilot
4. **Verify:** Autopilot remains active, camera rotates

---

## Constraints and Considerations

### Tilt Angle Limits

| Angle | Effect | Reason |
|-------|--------|--------|
| 0° (top-down) | Pure 2D view from above | Useful for orbital planning |
| 15° (default) | Slight 3D effect | Current default, good balance |
| 45° | Strong 3D perspective | Good for visualizing inclinations |
| 90° (edge-on) | View solar system from side | Shows Z-axis movement clearly |

### Performance

- Rotation calculations are trivial (basic trig)
- No additional render calls needed
- `project3D()` already handles rotated coordinates
- No impact on frame rate

### Browser Compatibility

- `contextmenu` event supported in all modern browsers
- `e.button === 2` for right-click is standard
- `e.buttons` bitmask for mouseenter detection is standard
- No polyfills required

### Known Limitations

| Limitation | Impact | Notes |
|------------|--------|-------|
| **No touch/mobile support** | Touch devices cannot rotate view | Consider adding two-finger rotation in future |
| **Context menu suppressed** | Users cannot right-click for browser options | Intentional trade-off for rotation |
| **Grid circles not 3D** | Grid stays circular when rotated | Visual artifact, not functional issue |
| **Orbits collapse edge-on** | At 90° tilt, orbits become lines | Mathematically correct behavior |

---

## Future Enhancements (Out of Scope)

These are not part of this implementation but could be added later:

1. **Touch support** - Two-finger rotation for tablets (HIGH PRIORITY)
2. **Smooth/animated rotation** - Ease-in/ease-out when using keyboard
3. **View presets** - Buttons for "Top", "Side", "Isometric" views
4. **Rotation indicator** - UI showing current angles
5. **Z-axis panning** - When tilted, allow vertical pan to affect Z
6. **3D grid rendering** - Project grid through `project3D()` for proper ellipses

---

## Appendix: Complete Code Reference

### Helper Functions

```javascript
// Mouse button constants for readability
const MOUSE_BUTTON = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

// Rotation state for camera view manipulation
const rotateState = {
    isRotating: false,
    lastX: 0,
    lastY: 0
};

/**
 * Handle camera panning with rotation compensation
 * Uses INVERSE rotation matrix to convert screen-space deltas to world-space
 * @param {MouseEvent} e
 */
function handlePan(e) {
    const deltaX = e.clientX - dragState.lastX;
    const deltaY = e.clientY - dragState.lastY;

    const scale = getScale();
    const effectiveScale = scale * camera.zoom;

    const viewDeltaX = -deltaX / effectiveScale;
    const viewDeltaY = deltaY / effectiveScale;

    // Apply INVERSE rotation (transpose of forward rotation matrix)
    const cosZ = Math.cos(camera.angleZ);
    const sinZ = Math.sin(camera.angleZ);

    const worldDeltaX = viewDeltaX * cosZ + viewDeltaY * sinZ;
    const worldDeltaY = -viewDeltaX * sinZ + viewDeltaY * cosZ;

    camera.target.x += worldDeltaX;
    camera.target.y += worldDeltaY;

    dragState.lastX = e.clientX;
    dragState.lastY = e.clientY;
}

/**
 * Handle camera rotation from mouse drag
 * @param {MouseEvent} e
 */
function handleRotation(e) {
    const deltaX = e.clientX - rotateState.lastX;
    const deltaY = e.clientY - rotateState.lastY;

    const sensitivity = 0.005;

    camera.angleZ += deltaX * sensitivity;
    camera.angleZ = camera.angleZ % (2 * Math.PI);
    if (camera.angleZ < 0) camera.angleZ += 2 * Math.PI;

    camera.angleX -= deltaY * sensitivity;
    camera.angleX = Math.max(0, Math.min(Math.PI / 2, camera.angleX));

    rotateState.lastX = e.clientX;
    rotateState.lastY = e.clientY;
}
```

### Complete `initMouseControls()` Function

```javascript
/**
 * Set up mouse controls (wheel zoom, drag to pan, right-drag to rotate)
 * @param {HTMLCanvasElement} canvas
 */
function initMouseControls(canvas) {
    // Prevent context menu on canvas to allow right-click rotation
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Wheel zoom
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        camera.zoom *= e.deltaY > 0 ? 0.9 : 1.1;
        camera.zoom = Math.max(0.1, Math.min(5, camera.zoom));
    });

    // Mousedown - with mutual exclusion to prevent simultaneous pan+rotate
    canvas.addEventListener('mousedown', e => {
        if (e.button === MOUSE_BUTTON.LEFT && !rotateState.isRotating) {
            dragState.isDragging = true;
            dragState.lastX = e.clientX;
            dragState.lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
            stopFollowing();
        } else if (e.button === MOUSE_BUTTON.RIGHT && !dragState.isDragging) {
            rotateState.isRotating = true;
            rotateState.lastX = e.clientX;
            rotateState.lastY = e.clientY;
            canvas.style.cursor = 'move';
        }
    });

    // Mousemove - handle pan and rotate
    canvas.addEventListener('mousemove', e => {
        if (dragState.isDragging) {
            handlePan(e);
        }
        if (rotateState.isRotating) {
            handleRotation(e);
        }
    });

    // Mouseup - end actions
    canvas.addEventListener('mouseup', e => {
        if (e.button === MOUSE_BUTTON.LEFT) {
            dragState.isDragging = false;
        } else if (e.button === MOUSE_BUTTON.RIGHT) {
            rotateState.isRotating = false;
        }
        if (!dragState.isDragging && !rotateState.isRotating) {
            canvas.style.cursor = 'default';
        }
    });

    // Mouseleave - only reset cursor, preserve state
    canvas.addEventListener('mouseleave', () => {
        canvas.style.cursor = 'default';
    });

    // Mouseenter - check if buttons released while off-canvas
    canvas.addEventListener('mouseenter', e => {
        // e.buttons bitmask: 1 = left, 2 = right, 4 = middle
        if (dragState.isDragging && !(e.buttons & 1)) {
            dragState.isDragging = false;
        }
        if (rotateState.isRotating && !(e.buttons & 2)) {
            rotateState.isRotating = false;
        }
    });
}
```

### Keyboard Shortcuts Addition

```javascript
// Add to initKeyboardShortcuts() at the beginning of the keydown handler
document.addEventListener('keydown', e => {
    // Camera rotation shortcuts (always active)
    const rotationStep = 0.05;
    const tiltStep = 0.05;

    switch (e.key.toLowerCase()) {
        case 'q':
            camera.angleZ -= rotationStep;
            if (camera.angleZ < 0) camera.angleZ += 2 * Math.PI;
            break;
        case 'e':
            camera.angleZ += rotationStep;
            camera.angleZ = camera.angleZ % (2 * Math.PI);
            break;
        case 'r':
            if (!e.ctrlKey && !e.metaKey) {
                camera.angleX = 15 * Math.PI / 180;
                camera.angleZ = 0;
            }
            break;
        case 'w':
            camera.angleX = Math.max(0, camera.angleX - tiltStep);
            break;
        case 's':
            camera.angleX = Math.min(Math.PI / 2, camera.angleX + tiltStep);
            break;
    }

    // ... existing autopilot and sail controls continue below
});
```

---

*End of Implementation Plan*
